import uuid

def toJSON(obj):
    return JSON.stringify(obj, undefined, 4)
def toBlob(obj):
    return new Blob([toJSON(obj)], {"type": 'text/json'})

class Campaign:
    def __init__(self, title):
        self.title = title
        self.campaign = []
        self._pending_operations = []

    def newPendingOperation(self):
        id = str(uuid.uuid4())
        self._pending_operations.append(id)
        return id

    def hasPendingOperation(self):
        return self._pending_operations.length > 0

    def completedOperation(self, id):
        self._pending_operations.remove(id)
        console.log("Completed Operation ", id, " we have ", self._pending_operations.length, " remaining operations")
        return not self.hasPendingOperation()

    def parsePage(self, page):
        data = page.toJSON()
        data.zorder = data.zorder.split(",")
        data.graphics = page.thegraphics.toJSON() if page.thegraphics? else []
        data.texts = page.thetexts.toJSON() if page.thetexts? else []
        data.paths = page.thepaths.toJSON() if page.thepaths? else []
        for path in data.paths:
            path.path = JSON.parse(path.path)
        return data

    def parsePages(self, pages):
        array = []
        for page in pages.models:
            array.append(self.parsePage(page))
        console.log("Finished parsing pages.")
        return array

    def updateModel(self, data, key, blob, id, cb):
        console.log ("Received ", key, " for ", data.name)
        if key in ["bio", "gmnotes", "notes"]:
            data[key] = unescape(blob)
        elif key == "defaulttoken":
            data[key] = JSON.parse(blob)
        else:
            data[key] = blob
        if self.completedOperation(id) and cb:
            cb()

    
    def parseCharacter(self, character, cb):
        data = character.toJSON()
        if data.bio != "":
            del data.bio
            bio_id = self.newPendingOperation()
            character._getLatestBlob("bio", def(blob):
                                         self.updateModel(data, "bio", blob, bio_id, cb)
                                     )
        if data.gmnotes != "":
            del data.gmnotes
            gmnotes_id = self.newPendingOperation()
            character._getLatestBlob("gmnotes", def(blob):
                                         self.updateModel(data, "gmnotes", blob, gmnotes_id, cb)
                                     )
        if data.defaulttoken != "":
            del data.defaulttoken
            token_id = self.newPendingOperation()
            character._getLatestBlob("defaulttoken", def(blob):
                                         self.updateModel(data, "defaulttoken", blob, token_id, cb)
                                     )
        data.attributes = character.attribs.toJSON()
        data.abilities = character.abilities.toJSON()
        return data

    def parseCharacters(self, characters, cb):
        array = []
        for character in characters.models:
            array.append(self.parseCharacter(character, cb))
        console.log("Finished parsing characters.")
        return array

    def parseHandout(self, handout, cb):
        data = handout.toJSON()
        if data.notes != "":
            del data.notes
            notes_id = self.newPendingOperation()
            handout._getLatestBlob("notes", def(blob):
                                       self.updateModel(data, "notes", blob, notes_id, cb)
                                   )
        if data.gmnotes != "":
            del data.gmnotes
            gmnotes_id = self.newPendingOperation()
            handout._getLatestBlob("gmnotes", def(blob):
                                       self.updateModel(data, "gmnotes", blob, gmnotes_id, cb)
                                   )
        return data

    def parseHandouts(self, handouts, cb):
        array = []
        for handout in handouts.models:
            array.append(self.parseHandout(handout, cb))
        console.log("Finished parsing handouts.")
        return array

    def parseCampaign(self, cb):
        result = window.Campaign.toJSON()
        self.campaign = result
        done = def():
            if cb:
                cb(result)
        # Make sure we don't get callback called before we finish parsing all the items
        id = self.newPendingOperation()
        result.handouts = self.parseHandouts(window.Campaign.handouts, done)
        result.characters = self.parseCharacters(window.Campaign.characters, done)
        result.pages = self.parsePages(window.Campaign.pages)
        result.journalfolder = JSON.parse(result.journalfolder)
        result.turnorder = JSON.parse(result.turnorder)
        if self.completedOperation(id):
            done()
        return result

    def saveCampaign(self, campaign, filename=None):
        saveAs(toBlob(campaign), filename if filename else (self.title + ".json"))

    def exportCampaignJson(self, filename=None):
        save = def():
            self.saveCampaign(campaign, filename)
        self.campaign = self.parseCampaign(save)

    def exportCampaign(self):
        self.exportCampaignJson()

    def downloadResource(self, url, cb, finallyCB=None):
        id = self.newPendingOperation()
        fetch(url).then(def(response):
            if response.status == 200 or response.status == 0:
                return Promise.resolve(response.blob());
            else:
                return Promise.reject(new Error(response.statusText));
        ).then(cb).finally(def(error):
                self.completedOperation(id)
                if finallyCB:
                    finallyCB()
        )

    def saveCampaignZip(self, campaign, filename=None):
        zip = new JSZip()
        zip.file('campaign.json', toJSON(campaign))
        self.zip = zip
        saveZip = def(blob):
            saveAs(blob, filename if filename else (self.title + ".zip"))
        checkZipDone = def():
            if not self.hasPendingOperation():
                zip.generateAsync({"type":"blob"}, def (metadata):
                                      console.log("progression: " + metadata.percent + " %")
                                  ).then(saveZip).catch(def (error):
                                                            console.log("Error generating zip : ", error)
                                                        )
        makeAddBlobToZip = def(folder, filename):
            return def(blob):
                console.log("Got blob for ", filename, " : ", blob)
                folder.file(filename, blob)
                checkZipDone()
                                          
        if campaign.characters.length > 0:
            characters = zip.folder("characters")
            names = []
            for char in campaign.characters:
                name = char.name
                idx = 1
                while name in names:
                    name = char.name + "(" + idx + ")"
                    idx += 1
                names.append(name)
                char_dir = characters.folder(name)
                char_dir.file("character.json", toBlob(char))
                if (char.avatar? "") != "":
                    self.downloadResource(char.avatar, makeAddBlobToZip(char_dir, "avatar.png"), checkZipDone)
                if char.defaulttoken? and (char.defaulttoken.imgsrc? "") != "":
                    self.downloadResource(char.defaulttoken.imgsrc, makeAddBlobToZip(char_dir, "token.png"), checkZipDone)
                if (char.bio? "") != "":
                    char_dir.file("bio.html", new Blob([char.bio]))
                if (char.gmnotes? "") != "":
                    char_dir.file("gmnotes.html", new Blob([char.gmnotes]))
        checkZipDone()

    def exportCampaignZip(self, filename=None):
        save = def(campaign):
            self.saveCampaignZip(campaign, filename)
        self.campaign = self.parseCampaign(save)

console.log("Roll20 Campaign exporter loaded")
window.R20Exporter = new Campaign($("head title").text().trim().replace(" | Roll20", ""))
