import uuid

def toJSON(obj):
    return JSON.stringify(obj, undefined, 4)
def toBlob(obj):
    return new Blob([toJSON(obj)], {"type": 'text/json'})

class Campaign:
    def __init__(self, title):
        self.title = title
        self.campaign = {}
        self.zip = None
        self._pending_operations = []
        self._total_size = 0

    def newPendingOperation(self):
        id = str(uuid.uuid4())
        self._pending_operations.append(id)
        return id

    def hasPendingOperation(self):
        return self._pending_operations.length > 0

    def completedOperation(self, id):
        try:
            self._pending_operations.remove(id)
        except:
            pass
        left = self._pending_operations.length
        display = (left > 100 and left % 100 == 0) or (left < 100 and left % 10 == 0)
        if display:
            console.log("Download operations still in progress : ", left)
        return not self.hasPendingOperation()

    def findID(self, id, obj_type=None):
        find_id = def (o): return o.id == id
        if obj_type == "handout" or obj_type is None:
            handout = self.campaign.handouts.find(find_id)
            if handout?:
                return handout
        if obj_type == "page" or obj_type is None:
            page = self.campaign.pages.find(find_id)
            if page?:
                return page
        if obj_type == "character" or obj_type is None:
            char = self.campaign.characters.find(find_id)
            if char?:
                return char
        if obj_type == "track" or obj_type is None:
            track = self.campaign.jukebox.find(find_id)
            if track?:
                return track
        return None

    def _createZipFile(self):
        return  new window.zip.fs.FS().root

    def _addZipFolder(self, zip, filename):
        return zip.addDirectory(filename)

    def _addFileToZip(self, zip, filename, content):
        zip.addBlob(filename, content)
        if content.size?:
            self._total_size += content.size
        elif content.length?:
            self._total_size += content.length

    def _exportZip(self, zip, fileEntry, onend, onprogress, onerror):
        window.zip.useWebWorkers = False
        self._current_size = 0

        done = def(writer): writer.close(onend)

        addEntryToZipWriter = def(writer, zip):
            setTimeout(def(): addEntryToZipWriterDelayed(writer, zip);, 0)

        addEntryToZipWriterDelayed = def(writer, zip):
            makeCB = def(c):
                return def():
                    self._current_size += c.data.size if c.data? else 0
                    onprogress(self._current_size, self._total_size)
                    addEntryToZipWriter(writer, zip)
            partialprogress = def(bytes):
                onprogress(self._current_size + bytes, self._total_size)

            # Find the current folder/item we need to add
            current = zip 
            for idx in self._zip_add_indices:
                current = current.children[idx]

            # We're out of children, go back to the parent
            if not current?:
                self._zip_add_indices.pop()
                # If the list is empty, we've gone back to the root and we're done
                if self._zip_add_indices.length == 0:
                    done(writer)
                else:
                    # Now that we're done with this folder, go to the next child of the parent
                    self._zip_add_indices[-1] += 1
                    addEntryToZipWriterDelayed(writer, zip)
                return
            
            if current.directory:
                # Add the directory and when we're done, start adding its children from index 0
                self._zip_add_indices.append(0)
                writer.add(current.getFullname(), None, makeCB(current),
                           partialprogress, {"directory" : current.directory, "version" : current.zipVersion})
            else:
                # Add the file and when we're done, add the next child of the parent
                self._zip_add_indices[-1] += 1
                writer.add(current.getFullname(), new current.Reader(current.data, onerror), makeCB(current),
                           partialprogress, {"version" : current.zipVersion})
                       
        zipWriterCreated = def(writer):
            # Need to keep list of where we are in the add process, it seems
            # that we can't add two files at the same time, they conflict and we
            # can't add them recursively like zip.fs.FS.exportZip does because we'll
            # run out of stack quickly due to the number of files.
            self._zip_add_indices = [0]
            addEntryToZipWriter(writer, zip)
                
        window.zip.createWriter(new window.zip.FileWriter(fileEntry, "application/zip"), zipWriterCreated, onerror)

    # Based on https://gildas-lormeau.github.io/zip.js/demos/demo1.js
    def _saveZipToFile(self, zip, filename):
        BYTES = ["Bytes", "KB", "MB", "GB"]
        DIV = [1, 1024, 1024 * 1024, 1024 * 1024 * 1024]
        size = self._total_size
        div = 0
        while (size / 1024) > 0 and div +1 < DIV.length:
            size /= 1024
            div += 1
        console.log("Done downloading resources!")
        console.log("Generating ZIP file with ", size.toFixed(2), BYTES[div] + " of data")
        console.warn("It is highly recommended to keep this tab focused and the window non-minimized during the entire process\n"
                     "otherwise it could take hours instead of minutes to generate the ZIP file for your campaign.\n"
                     "You can separate the tab into its own window if you want to keep using your browser in the meantime.")

        requestFileSystem = window.webkitRequestFileSystem or window.mozRequestFileSystem or window.requestFileSystem

        createTempFile = def(tempCB):
            tmpFilename = "tmp.zip"
            requestFileSystem(window.TEMPORARY, 4 * 1024 * 1024 * 1024,
                              def(filesystem):
                                  create = def():
                                      filesystem.root.getFile(tmpFilename, {"create" : True},
                                                              def (zipFile): tempCB(zipFile);)
                                  # Get the tmp.zip if it exists then delete it and create new
                                  filesystem.root.getFile(tmpFilename, None,
                                                          def (entry): entry.remove(create, create);, create)
                              )

        # Create a tmp.zip file in temporary storage
        createTempFile(def (fileEntry):
                           self._last_progress = -5
                           self._exportZip(zip, fileEntry,
                                           def ():
                                               console.log("Congratulations! The Campaign.zip file was generated successfully.\nStarting download.")
                                               fileEntry.file(def (f): window.saveAs(f, filename);)
                                           , def (current, total):
                                               percent = 100 * current / total
                                               if percent - self._last_progress >= 5:
                                                   console.log("Zip file generated : " + percent.toFixed(2) + " %")
                                                   self._last_progress = (percent // 5) * 5
                                           , def (message):
                                               console.log("Error creating zip file writer : ", message)
                                           )
                       )

    def parsePage(self, page):
        data = page.toJSON()
        data.zorder = data.zorder.split(",")
        data.graphics = page.thegraphics.toJSON() if page.thegraphics? else []
        data.texts = page.thetexts.toJSON() if page.thetexts? else []
        data.paths = page.thepaths.toJSON() if page.thepaths? else []
        for path in data.paths:
            path.path = JSON.parse(path.path)
        return data

    def parsePages(self, pages):
        array = []
        for page in pages.models:
            if page.fullyLoaded:
                array.append(self.parsePage(page))
            else:
                # Archived pages are not loaded. We can tell them to load but we have
                # no callbacks on when that is done, so we need to wait before parsing them.
                id = self.newPendingOperation()
                makeCB = def(a, i, p):
                    return def():
                        a.append(self.parsePage(p))
                        self.completedOperation(i)
                page.fullyLoadPage()
                setTimeout(makeCB(array, id, page), 1000)
        console.log("Finished parsing pages.")
        return array

    def updateModel(self, data, key, blob, id, cb):
        if key in ["bio", "gmnotes", "notes"]:
            data[key] = window.unescape(blob)
        elif key == "defaulttoken":
            data[key] = JSON.parse(blob)
        else:
            data[key] = blob
        if self.completedOperation(id) and cb:
            cb()

    
    def parseCharacter(self, character, cb):
        data = character.toJSON()
        data.inplayerjournals = data.inplayerjournals.split(",")
        data.controlledby = data.controlledby.split(",")
        if data.bio != "":
            del data.bio
            bio_id = self.newPendingOperation()
            character._getLatestBlob("bio", def(blob): self.updateModel(data, "bio", blob, bio_id, cb);)
        if data.gmnotes != "":
            del data.gmnotes
            gmnotes_id = self.newPendingOperation()
            character._getLatestBlob("gmnotes", def(blob): self.updateModel(data, "gmnotes", blob, gmnotes_id, cb);)
        if data.defaulttoken != "":
            del data.defaulttoken
            token_id = self.newPendingOperation()
            character._getLatestBlob("defaulttoken", def(blob): self.updateModel(data, "defaulttoken", blob, token_id, cb);)
        data.attributes = character.attribs.toJSON()
        data.abilities = character.abilities.toJSON()
        return data

    def parseCharacters(self, characters, cb):
        array = []
        for character in characters.models:
            array.append(self.parseCharacter(character, cb))
        console.log("Finished parsing characters.")
        return array

    def parseHandout(self, handout, cb):
        data = handout.toJSON()
        data.inplayerjournals = data.inplayerjournals.split(",")
        data.controlledby = data.controlledby.split(",")
        if data.notes != "":
            del data.notes
            notes_id = self.newPendingOperation()
            handout._getLatestBlob("notes", def(blob): self.updateModel(data, "notes", blob, notes_id, cb);)
        if data.gmnotes != "":
            del data.gmnotes
            gmnotes_id = self.newPendingOperation()
            handout._getLatestBlob("gmnotes", def(blob): self.updateModel(data, "gmnotes", blob, gmnotes_id, cb);)
        return data

    def parseHandouts(self, handouts, cb):
        array = []
        for handout in handouts.models:
            array.append(self.parseHandout(handout, cb))
        console.log("Finished parsing handouts.")
        return array

    def parsePlayer(self, player):
        data = player.toJSON()
        if data.journalfolderstatus:
            data.journalfolderstatus = data.journalfolderstatus.split(",")
        if data.jukeboxfolderstatus:
            data.jukebosfolderstatus = data.jukeboxfolderstatus.split(",")
        if data.macrobar:
            data.macrobar = data.macrobar.split(",")
        if data.adv_fow_revealed:
            data.adv_fow_revealed = JSON.parse(data.adv_fow_revealed)
        return data

    def parsePlayers(self, players):
        array = []
        for player in players.models:
            array.append(self.parsePlayer(player))
        console.log("Finished parsing players.")
        return array

    def loadArchivedPages(self):
        num_loaded = 0
        for page in window.Campaign.pages.models:
            if not page.fullyLoaded:
                page.fullyLoadPage()
                num_loaded += 1
        return num_loaded

    def _parseChatArchiveHTML(self, obj, html):
        scripts = window.$(html).filter("script[type='text/javascript']")
        prefix = "var msgdata = \""
        for i in range(scripts.length):
            content = scripts[i].textContent.trim()
            if content.startsWith(prefix):
                start = len(prefix)
                end = content.indexOf("\";", start)
                try:
                    chat = window.atob(content[start:end])
                    obj.chat_archive = JSON.parse(chat)
                except Exception as e:
                    console.log("Unable to parse chat data: ", e)
                break
                
    def _fetchChatArchive(self, obj, done):
        id = self.newPendingOperation()
        errorcb = def():
            if self.completedOperation(id) and done:
                done()
        cb = def(blob):
            f = new FileReader()
            f.onerror = errorcb
            f.onabort = errorcb
            f.onload = def():
                self._parseChatArchiveHTML(obj, f.result)
                if self.completedOperation(id) and done:
                    done()
            f.readAsText(blob)
        self.downloadResource("https://app.roll20.net/campaigns/chatarchive/" + obj.campaign_id, cb, errorcb)

    def _parseCampaignDelayed(self, result, cb):
        done = def():
            if cb:
                cb(result)
        # Make sure we don't get callback called before we finish parsing all the items
        id = self.newPendingOperation()
        result.handouts = self.parseHandouts(window.Campaign.handouts, done)
        result.characters = self.parseCharacters(window.Campaign.characters, done)
        result.pages = self.parsePages(window.Campaign.pages)
        result.players = self.parsePlayers(window.Campaign.players)
        result.jukebox = window.Jukebox.playlist.toJSON()
        self._fetchChatArchive(result, done)
        if result.jukeboxfolder != "":
            result.jukeboxfolder = JSON.parse(result.jukeboxfolder)
        if result.journalfolder != "":
            result.journalfolder = JSON.parse(result.journalfolder)
        if result.turnorder != "":
            result.turnorder = JSON.parse(result.turnorder)
        console.log("Download operations in progress : ", self._pending_operations.length)
        if self.completedOperation(id):
            done()

    def parseCampaign(self, cb):
        num_loaded = self.loadArchivedPages()
        result = window.Campaign.toJSON()
        result.campaign_title = self.title
        result.account_id = window.d20_account_id
        result.campaign_id = window.campaign_id
        self.campaign = result

        console.log("Waiting ", num_loaded * 5, " seconds for ", num_loaded, " archived pages to finish loading")
        setTimeout(def(): self._parseCampaignDelayed(result, cb);, num_loaded * 5000)
        return result

    def saveCampaign(self, filename=None):
        window.saveAs(toBlob(self.campaign), filename if filename else (self.title + ".json"))

    def exportCampaignJson(self, filename=None):
        self.parseCampaign(def(): self.saveCampaign(filename);)

    def exportCampaign(self):
        self.exportCampaignJson()

    def downloadResource(self, url, cb, errorCB=None):
        id = self.newPendingOperation()
        
        window.fetch(url).then(def(response):
            if response.status == 200 or response.status == 0:
                return Promise.resolve(response.blob())
            else:
                return Promise.reject(new Error(response.statusText))
        ).then(def (blob):
            self.completedOperation(id)
            if cb:
                cb(blob)
        ).catch(def (error):
            console.log("Error downloading ", url, " : ", error)
            self.completedOperation(id)
            if errorCB:
                errorCB()
        )

    # Most avatar/imgsrc URLs use the 'med' filename, even for the huge map files. We should download the appropriate sized
    # file depending on the image size we are looking for. We just download the highest resolution file that we can instead.
    def downloadR20Resource(self, folder, prefix, url, finallyCB, try_files=["original", "max", "med", "thumb"]):
        filename = url.split("/")[-1].split(".")[0]

        # This is needed so we download the higher res file first.
        # Unfortunately, there are some CORS issues sometimes, so if higher res file fails, download the lower one.
        if try_files.length > 0:
            if filename in ["original", "max", "med", "thumb"]:
                new_url = url.replace("/" + filename + ".", "/" + try_files[0] + ".")
            else:
                new_url = url
                try_files = [""]

            errorCB = def():
                self.downloadR20Resource(folder, prefix, url, finallyCB, try_files[1:])
            self.downloadResource(new_url, self._makeAddBlobToZip(folder, prefix + ".png", finallyCB), errorCB)
        else:
            console.log("Couldn't download ", url, " with any alternative filename. Resource has become unavailable")
            finallyCB()
            

    def _makeNameUnique(self, names, orig_name):
        name = str(names.length).padStart(3, "0") + " - " + orig_name
        names.append(name)
        return name

    def _flattenJournalEntries(self, journal, _list=[]):
        for entry in journal:
            if jstype(entry) == "string":
                _list.append(entry)
            else:
                self._flattenJournalEntries(entry.i, _list)
        return _list

    def _makeAddBlobToZip(self, folder, filename, finallyCB):
        return def(blob):
            self._addFileToZip(folder, filename, blob)
            finallyCB()

    def _addCharacterToZip(self, folder, character, finallyCB):
        self._addFileToZip(folder, "character.json", toBlob(character))
        if (character.avatar? "") != "":
            self.downloadR20Resource(folder, "avatar", character.avatar, finallyCB)
        if character.defaulttoken? and (character.defaulttoken.imgsrc? "") != "":
            self.downloadR20Resource(folder, "token", character.defaulttoken.imgsrc, finallyCB)
        if (character.bio? "") != "":
            self._addFileToZip(folder, "bio.html", new Blob([character.bio]))
        if (character.gmnotes? "") != "":
            self._addFileToZip(folder, "gmnotes.html", new Blob([character.gmnotes]))

    def _addHandoutToZip(self, folder, handout, finallyCB):
        self._addFileToZip(folder, "handout.json", toBlob(handout))
        if (handout.avatar? "") != "":
            self.downloadR20Resource(folder, "avatar", handout.avatar, finallyCB)
        if (handout.notes? "") != "":
            self._addFileToZip(folder, "notes.html", new Blob([handout.notes]))
        if (handout.gmnotes? "") != "":
            self._addFileToZip(folder, "gmnotes.html", new Blob([handout.gmnotes]))

    def _addJournalToZip(self, folder, journal, finallyCB):
        names = []
        for journal_entry in journal:
            if jstype(journal_entry) == "string":
                handout = self.findID(journal_entry, "handout")
                if handout is not None:
                    name = self._makeNameUnique(names, handout.name)
                    handout_dir = self._addZipFolder(folder, name)
                    self._addHandoutToZip(handout_dir, handout, finallyCB)
                else:
                    character = self.findID(journal_entry, "character")
                    if character is not None:
                        name = self._makeNameUnique(names, character.name)
                        char_dir = self._addZipFolder(folder, name)
                        self._addCharacterToZip(char_dir, character, finallyCB)
                    else:
                        console.log("Can't find handout with ID : ", journal_entry)
                        continue
            else:
                name = self._makeNameUnique(names, journal_entry.n)
                child_dir = self._addZipFolder(folder, name)
                self._addJournalToZip(child_dir, journal_entry.i, finallyCB)

    def _addPlaylistToZip(self, folder, playlist, finallyCB):
        names = []
        for audio in playlist:
            if jstype(audio) == "string":
                track = self.findID(audio, "track")
                if track is not None:
                    name = self._makeNameUnique(names, track.title)
                    if name[-4] != ".mp3":
                        name += ".mp3"
                    if track.source == "My Audio":
                        url = "https://app.roll20.net/audio_library/play/" + track.track_id
                    elif track.source == "Tabletop Audio":
                        url = "https://s3.amazonaws.com/cdn.roll20.net/ttaudio/" + track.track_id.split("-")[0]
                    elif track.source == "Incompetech":
                        url =  "https://s3.amazonaws.com/cdn.roll20.net/incompetech/" + track.track_id.split("-")[0]
                    else:
                        url = None
                        console.log("Can't download Audio track (", track.title , "). Unsupported source : ", track.source)
                    if url:
                        errorCB = def():
                            console.log("Couldn't download Jukebox audio from url : ", url)
                        self.downloadResource(url, self._makeAddBlobToZip(folder, name, finallyCB), errorCB)
                else:
                    console.log("Can't find Audio Track with ID : ", track)
                    continue
            else:
                name = self._makeNameUnique(names, audio.n)
                child_dir = self._addZipFolder(folder, name)
                self._addPlaylistToZip(child_dir, audio.i, finallyCB)

    def _addPageToZip(self, folder, page, finallyCB):
        self._addFileToZip(folder, "page.json", toBlob(page))
        if (page.thumbnail? "") != "":
            self.downloadR20Resource(folder, "thumbnail", page.thumbnail, finallyCB)
        if page.graphics.length > 0:
            graphics = self._addZipFolder(folder, "graphics")
            for graphic in page.graphics:
                self.downloadR20Resource(graphics, graphic.id, graphic.imgsrc, finallyCB)

    def _saveCampaignZipCharacters(self, checkZipDone):
        console.log("Saving Characters")
        if self.campaign.characters.length > 0:
            characters = self._addZipFolder(self.zip, "characters")
            names = []
            for character in self.campaign.characters:
                name = self._makeNameUnique(names, character.name)
                char_dir = self._addZipFolder(characters, name)
                self._addCharacterToZip(char_dir, character, checkZipDone)

        self.savingStep = 1
        checkZipDone()

    def _saveCampaignZipJournal(self, checkZipDone):
        console.log("Saving Journal")
        if self.campaign.journalfolder.length > 0:
            journal = self._addZipFolder(self.zip, "journal")
            self._addJournalToZip(journal, self.campaign.journalfolder, checkZipDone)
            all_ids = self._flattenJournalEntries(self.campaign.journalfolder)
            orphaned = []
            archived = []
            for handout in self.campaign.handouts:
                if handout.id not in all_ids:
                    orphaned.append(handout.id)
                elif handout.archived:
                    archived.append(handout.id)
            if archived.length > 0:
                folder = self._addZipFolder(journal, "Archived Handouts")
                self._addJournalToZip(folder, archived, checkZipDone)
            if orphaned.length > 0:
                folder = self._addZipFolder(journal, "Orphaned Handouts")
                self._addJournalToZip(folder, orphaned, checkZipDone)

        self.savingStep = 2
        checkZipDone()

    def _saveCampaignZipPage(self, checkZipDone):
        if self.savingPageIdx >= self.campaign.pages.length:
            self.savingStep = 4
        else:
            page = self.campaign.pages[self.savingPageIdx]
            self.savingPageIdx += 1
            name = page.name if len(page.name) > 0  else "Untitled"
            console.log("Saving Page : ", name)
            name = self._makeNameUnique(self.names, name)
            page_dir = self._addZipFolder(self.pages, name)
            self._addPageToZip(page_dir, page, checkZipDone)

        checkZipDone()

    def _saveCampaignZipPages(self, checkZipDone):
        console.log("Saving ", self.campaign.pages.length, " Pages")
        if self.campaign.pages.length > 0:
            self.pages = self._addZipFolder(self.zip, "pages")
            self.names = []
        self.savingStep = 3
        self.savingPageIdx = 0
        checkZipDone()

    def _saveCampaignZipJukebox(self, checkZipDone):
        console.log("Saving Jukebox audio")
        if self.campaign.jukeboxfolder.length > 0:
            jukebox = self._addZipFolder(self.zip, "jukebox")
            self._addPlaylistToZip(jukebox, self.campaign.jukeboxfolder, checkZipDone)
        self.savingStep = 5
        self.savingPageIdx = 0
        checkZipDone()

    def saveCampaignZip(self, filename=None):
        if self.zip is not None:
            console.error("Saving already in progress. Can't be cancelled.")
            return
        filename = filename if filename else (self.title + ".zip")
        self.zip = self._createZipFile()
        self._total_size = 0
        self.savingStep = 0
        self._addFileToZip(self.zip, 'campaign.json', toBlob(self.campaign))
        if self.campaign.chat_archive?:
            self._addFileToZip(self.zip, 'chat_archive.json', toBlob(self.campaign.chat_archive))
        checkZipDone = def():
            if not self.hasPendingOperation():
                #console.log("No more pending operations. Current step is ", self.savingStep)
                if self.savingStep == 0:
                    self._saveCampaignZipCharacters(checkZipDone)
                elif self.savingStep == 1:
                    self._saveCampaignZipJournal(checkZipDone)
                elif self.savingStep == 2:
                    self._saveCampaignZipPages(checkZipDone)
                elif self.savingStep == 3:
                    self._saveCampaignZipPage(checkZipDone)
                elif self.savingStep == 4:
                    self._saveCampaignZipJukebox(checkZipDone)
                else:
                    self._saveZipToFile(self.zip, filename)
                    self.zip = None
                console.log("Download operations in progress : ", self._pending_operations.length)

        checkZipDone()

    def exportCampaignZip(self, filename=None):
        self.parseCampaign(def(campaign):self.saveCampaignZip(filename);)

console.log("Roll20 Campaign exporter loaded.")
console.log("To export your Roll20 campaign, enter R20Exporter.exportCampaignZip() and be patient.")
console.log("DISCLAIMER: Please note that using this tool to export a module from the marketplace may infringe on the Marketplace Asset License and/or Roll20 EULA.")
window.R20Exporter = new Campaign(window.$("head title").text().trim().replace(" | Roll20", ""))
