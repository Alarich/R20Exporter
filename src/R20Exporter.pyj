import uuid

def toJSON(obj):
    return JSON.stringify(obj, undefined, 4)

def toBlob(obj):
    return new Blob([toJSON(obj)], {"type": 'text/json'})

class Campaign:
    TOTAL_STEPS = 10
    def __init__(self, title):
        self.title = title
        self.campaign = {}
        self.zip = None
        self._pending_operations = []
        self._total_size = 0
        self.console = new ModalWindow("Exporting Campaign to ZIP file", "r20exporter-modal")
        self.console.warn("Note that you should not open a different campaign in Roll20 as it can interfere with the download of some resources.")
        self.console.warn("<strong>DISCLAIMER: Please note that using this tool to export a module from the marketplace may infringe on the Marketplace Asset License and/or Roll20 EULA.</strong>")
        $('#r20exporter').remove()
        button = $('<a class="btn" id="r20exporter">Export Campaign to ZIP</a>')
        content = $("#mysettings .content")
        content.prepend(button)
        button.css("width", "calc(100% - " + content.css("padding-right") + " - " + content.css("padding-left") + ")")
        button.on('click', def(): self.exportCampaignZip();)

    def newPendingOperation(self):
        id = str(uuid.uuid4())
        self._pending_operations.append(id)
        self._updateSecondProgress()
        return id

    def hasPendingOperation(self):
        return self._pending_operations.length > 0

    def completedOperation(self, id):
        try:
            self._pending_operations.remove(id)
        except:
            pass
        self._updateSecondProgress()
        return not self.hasPendingOperation()

    def clearPendingOperations(self):
        self._pending_operations = []
        self._updateSecondProgress()
        
    def _updateSecondProgress(self):
        left = self._pending_operations.length
        self.console.setLabel2(str(left) + " operations in progress")
        total = self.console.second_progress.total
        if left > total:
            total = left
        if left == 0:
            left = total = 1
        self.console.setProgress2(total - left, total)

    def findID(self, id, obj_type=None):
        find_id = def (o): return o.id == id
        if obj_type == "handout" or obj_type is None:
            handout = self.campaign.handouts.find(find_id)
            if handout?:
                return handout
        if obj_type == "page" or obj_type is None:
            page = self.campaign.pages.find(find_id)
            if page?:
                return page
        if obj_type == "character" or obj_type is None:
            char = self.campaign.characters.find(find_id)
            if char?:
                return char
        if obj_type == "track" or obj_type is None:
            track = self.campaign.jukebox.find(find_id)
            if track?:
                return track
        return None

    def _createZipFile(self):
        return  new window.zip.fs.FS().root

    def _addZipFolder(self, zip, filename):
        return zip.addDirectory(filename)

    def _addFileToZip(self, zip, filename, content):
        zip.addBlob(filename, content)
        if content.size?:
            self._total_size += content.size
        elif content.length?:
            self._total_size += content.length

    def _exportZip(self, zip, fileEntry, onend, onprogress, onerror):
        window.zip.useWebWorkers = False
        self._current_size = 0

        done = def(writer): writer.close(onend)

        addEntryToZipWriter = def(writer, zip):
            setTimeout(def(): addEntryToZipWriterDelayed(writer, zip);, 0)

        addEntryToZipWriterDelayed = def(writer, zip):
            makeCB = def(c):
                return def():
                    self._current_size += c.data.size if c.data? else 0
                    onprogress(self._current_size, self._total_size)
                    addEntryToZipWriter(writer, zip)
            partialprogress = def(bytes):
                onprogress(self._current_size + bytes, self._total_size)

            # Find the current folder/item we need to add
            current = zip 
            for idx in self._zip_add_indices:
                current = current.children[idx]

            # We're out of children, go back to the parent
            if not current?:
                self._zip_add_indices.pop()
                # If the list is empty, we've gone back to the root and we're done
                if self._zip_add_indices.length == 0:
                    done(writer)
                else:
                    # Now that we're done with this folder, go to the next child of the parent
                    self._zip_add_indices[-1] += 1
                    addEntryToZipWriterDelayed(writer, zip)
                return
            
            if current.directory:
                # Add the directory and when we're done, start adding its children from index 0
                self._zip_add_indices.append(0)
                writer.add(current.getFullname(), None, makeCB(current),
                           partialprogress, {"directory" : current.directory, "version" : current.zipVersion})
            else:
                # Add the file and when we're done, add the next child of the parent
                self._zip_add_indices[-1] += 1
                writer.add(current.getFullname(), new current.Reader(current.data, onerror), makeCB(current),
                           partialprogress, {"version" : current.zipVersion})
                       
        zipWriterCreated = def(writer):
            # Need to keep list of where we are in the add process, it seems
            # that we can't add two files at the same time, they conflict and we
            # can't add them recursively like zip.fs.FS.exportZip does because we'll
            # run out of stack quickly due to the number of files.
            self._zip_add_indices = [0]
            addEntryToZipWriter(writer, zip)
                
        window.zip.createWriter(new window.zip.FileWriter(fileEntry, "application/zip"), zipWriterCreated, onerror)

    # Based on https://gildas-lormeau.github.io/zip.js/demos/demo1.js
    def _saveZipToFile(self, zip, filename):
        BYTES = ["Bytes", "KB", "MB", "GB"]
        DIV = [1, 1024, 1024 * 1024, 1024 * 1024 * 1024]
        size = self._total_size
        div = 0
        while (size / 1024) > 1 and div +1 < DIV.length:
            size /= 1024
            div += 1
        self.console.warn("Done downloading resources!")
        self.console.warn("It is highly recommended to keep this tab focused and the window non-minimized during the entire process\n"
                     "otherwise it could take hours instead of minutes to generate the ZIP file for your campaign.\n"
                     "You can separate the tab into its own window if you want to keep using your browser in the meantime.")
        self.console.log("Generating ZIP file with ", size.toFixed(2), BYTES[div] + " of data")
        self.console.setLabel1("Generating " + str(size.toFixed(2)) + BYTES[div] + " ZIP file (" + self.TOTAL_STEPS + "/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(self.TOTAL_STEPS - 1, self.TOTAL_STEPS)

        requestFileSystem = window.webkitRequestFileSystem or window.mozRequestFileSystem or window.requestFileSystem

        createTempFile = def(tempCB):
            tmpFilename = "tmp.zip"
            requestFileSystem(window.TEMPORARY, 4 * 1024 * 1024 * 1024,
                              def(filesystem):
                                  create = def():
                                      filesystem.root.getFile(tmpFilename, {"create" : True},
                                                              def (zipFile): tempCB(zipFile);)
                                  # Get the tmp.zip if it exists then delete it and create new
                                  filesystem.root.getFile(tmpFilename, None,
                                                          def (entry): entry.remove(create, create);, create)
                              )

        # Create a tmp.zip file in temporary storage
        createTempFile(def (fileEntry):
                           self._exportZip(zip, fileEntry,
                                           def ():
                                               self.console.warn("Congratulations! The Campaign.zip file was generated successfully.\nStarting download.")
                                               self.console.setProgress1(self.TOTAL_STEPS, self.TOTAL_STEPS)
                                               setTimeout(def(): self.console.hide();, 5000)
                                               fileEntry.file(def (f): window.saveAs(f, filename);)
                                           , def (current, total):
                                               percent = 100 * current / total
                                               self.console.setProgress2(current, total)
                                               self.console.setLabel2("Generating ZIP file (" + percent.toFixed(2) + "%)")
                                           , def (message):
                                               self.console.log("Error creating zip file writer : ", message)
                                           )
                       )
    def _parseSides(self, sides):
        result = []
        side_list = sides.split("|")
        for side in side_list:
            if side != "":
                result.append(window.decodeURIComponent(side))
        return result

    def parsePage(self, page):
        data = page.toJSON()
        data.zorder = data.zorder.split(",")
        data.graphics = page.thegraphics.toJSON() if page.thegraphics? else []
        data.texts = page.thetexts.toJSON() if page.thetexts? else []
        data.paths = page.thepaths.toJSON() if page.thepaths? else []
        for path in data.paths:
            path.path = JSON.parse(path.path)
        for graphic in data.graphics:
            if graphic.sides?:
                graphic.sides = self._parseSides(graphic.sides)
        return data

    def parsePages(self, pages):
        array = []
        for page in pages.models:
            if page.fullyLoaded:
                array.append(self.parsePage(page))
            else:
                # Archived pages are not loaded. We can tell them to load but we have
                # no callbacks on when that is done, so we need to wait before parsing them.
                id = self.newPendingOperation()
                makeCB = def(a, i, p):
                    return def():
                        a.append(self.parsePage(p))
                        self.completedOperation(i)
                page.fullyLoadPage()
                setTimeout(makeCB(array, id, page), 1000)
        self.console.log("Finished parsing pages.")
        return array

    def updateModel(self, data, key, blob, id, cb):
        if key in ["bio", "gmnotes", "notes"]:
            data[key] = window.unescape(blob)
        elif key == "defaulttoken":
            try:
                data[key] = JSON.parse(blob)
            except:
                # Some one got invalid json data it seems
                data[key] = {}
            if data[key].sides?:
                data[key].sides = self._parseSides(data[key].sides)
        else:
            data[key] = blob
        if self.completedOperation(id) and cb:
            cb()

    
    def parseCharacter(self, character, cb):
        data = character.toJSON()
        data.inplayerjournals = data.inplayerjournals.split(",")
        data.controlledby = data.controlledby.split(",")
        if data.bio != "":
            del data.bio
            bio_id = self.newPendingOperation()
            character._getLatestBlob("bio", def(blob): self.updateModel(data, "bio", blob, bio_id, cb);)
        if data.gmnotes != "":
            del data.gmnotes
            gmnotes_id = self.newPendingOperation()
            character._getLatestBlob("gmnotes", def(blob): self.updateModel(data, "gmnotes", blob, gmnotes_id, cb);)
        if data.defaulttoken != "":
            del data.defaulttoken
            token_id = self.newPendingOperation()
            character._getLatestBlob("defaulttoken", def(blob): self.updateModel(data, "defaulttoken", blob, token_id, cb);)
        data.attributes = character.attribs.toJSON()
        data.abilities = character.abilities.toJSON()
        return data

    def parseCharacters(self, characters, cb):
        array = []
        for character in characters.models:
            array.append(self.parseCharacter(character, cb))
        self.console.log("Finished parsing characters.")
        return array

    def parseHandout(self, handout, cb):
        data = handout.toJSON()
        data.inplayerjournals = data.inplayerjournals.split(",")
        data.controlledby = data.controlledby.split(",")
        if data.notes != "":
            del data.notes
            notes_id = self.newPendingOperation()
            handout._getLatestBlob("notes", def(blob): self.updateModel(data, "notes", blob, notes_id, cb);)
        if data.gmnotes != "":
            del data.gmnotes
            gmnotes_id = self.newPendingOperation()
            handout._getLatestBlob("gmnotes", def(blob): self.updateModel(data, "gmnotes", blob, gmnotes_id, cb);)
        return data

    def parseHandouts(self, handouts, cb):
        array = []
        for handout in handouts.models:
            array.append(self.parseHandout(handout, cb))
        self.console.log("Finished parsing handouts.")
        return array

    def parsePlayer(self, player):
        data = player.toJSON()
        if data.journalfolderstatus:
            data.journalfolderstatus = data.journalfolderstatus.split(",")
        if data.jukeboxfolderstatus:
            data.jukebosfolderstatus = data.jukeboxfolderstatus.split(",")
        if data.macrobar:
            macros = data.macrobar.split(",")
            data.macrobar = []
            for macro in macros:
                if macro != "":
                    src, id = macro.split("|")
                    data.macrobar.append({"src": src, "id": id})
        if data.adv_fow_revealed:
            data.adv_fow_revealed = JSON.parse(data.adv_fow_revealed)
        return data

    def parsePlayers(self, players):
        array = []
        for player in players.models:
            array.append(self.parsePlayer(player))
        self.console.log("Finished parsing players.")
        return array

    def parseMacros(self, players):
        array = []
        for player in players.models:
            macros = player.macros.toJSON()
            for macro in macros:
                macro.player_id = player.id
            array.extend(macros)
        self.console.log("Finished parsing Macros.")
        return array

    def parseDecks(self, decks):
        array = []
        for deck in decks.models:
            data = deck.toJSON()
            cards = deck.cards.toJSON()
            data.cards = cards
            data.currentDeck = data.currentDeck.split(",")
            data.discardPile = data.discardPile.split(",")
            array.append(data)
        self.console.log("Finished parsing Decks.")
        return array

    def parseTables(self, tables):
        array = []
        for table in tables.models:
            data = table.toJSON()
            data.items = table.tableitems.toJSON()
            array.append(data)
        self.console.log("Finished parsing Rollable Tables.")
        return array

    def loadArchivedPages(self):
        num_loaded = 0
        for page in window.Campaign.pages.models:
            if not page.fullyLoaded:
                page.fullyLoadPage()
                num_loaded += 1
        return num_loaded

    def _parseChatArchiveHTML(self, obj, html):
        scripts = $(html).filter("script[type='text/javascript']")
        prefix = "var msgdata = \""
        for i in range(scripts.length):
            content = scripts[i].textContent.trim()
            if content.startsWith(prefix):
                start = len(prefix)
                end = content.indexOf("\";", start)
                try:
                    chat = window.atob(content[start:end])
                    obj.chat_archive = JSON.parse(chat)
                except Exception as e:
                    self.console.log("Unable to parse chat data: ", e)
                break
                
    def _fetchChatArchive(self, obj, done):
        id = self.newPendingOperation()
        errorcb = def():
            if self.completedOperation(id) and done:
                done()
        cb = def(blob):
            f = new FileReader()
            f.onerror = errorcb
            f.onabort = errorcb
            f.onload = def():
                self._parseChatArchiveHTML(obj, f.result)
                if self.completedOperation(id) and done:
                    done()
            f.readAsText(blob)
        self.downloadResource("https://app.roll20.net/campaigns/chatarchive/" + obj.campaign_id, cb, errorcb)

    def _parseCampaignDelayed(self, result, cb):
        done = def():
            if cb:
                cb(result)
        # Make sure we don't get callback called before we finish parsing all the items
        id = self.newPendingOperation()
        self.console.setLabel1("Extracting Campaign data (2/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(1, self.TOTAL_STEPS)
        result.handouts = self.parseHandouts(window.Campaign.handouts, done)
        result.characters = self.parseCharacters(window.Campaign.characters, done)
        result.pages = self.parsePages(window.Campaign.pages)
        result.players = self.parsePlayers(window.Campaign.players)
        result.macros = self.parseMacros(window.Campaign.players)
        result.decks = self.parseDecks(window.Campaign.decks)
        result.tables = self.parseTables(window.Campaign.rollabletables)
        result.jukebox = window.Jukebox.playlist.toJSON()
        self._fetchChatArchive(result, done)
        if result.jukeboxfolder != "":
            result.jukeboxfolder = JSON.parse(result.jukeboxfolder)
        if result.journalfolder != "":
            result.journalfolder = JSON.parse(result.journalfolder)
        if result.turnorder != "":
            result.turnorder = JSON.parse(result.turnorder)
        self.console.log("Download operations in progress : ", self._pending_operations.length)
        self.console.setProgress2(0, self._pending_operations.length)
        self.console.setLabel1("Downloading Journal Resources (3/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(2, self.TOTAL_STEPS)
        if self.completedOperation(id):
            done()

    def parseCampaign(self, cb):
        character_num_attributes = window.Campaign.characters.models.map(def (c): return c.attribs.length;)
        console.log(character_num_attributes)
        if not character_num_attributes.all(def (n): return n > 0;):
            num_loaded_sheets = character_num_attributes.count(def(n): return n > 0;)
            self.console.log("Waiting for character sheets to finish loading (" + num_loaded_sheets + "/" + character_num_attributes.length + ")")
            self.console.setLabel1("Waiting for character sheets to finish loading (1/" + self.TOTAL_STEPS + ")")
            self.console.setLabel2(num_loaded_sheets + "/" + character_num_attributes.length + " character sheets loaded")
            self.console.setProgress1(0, self.TOTAL_STEPS)
            self.console.setProgress2(num_loaded_sheets, character_num_attributes.length)
            return setTimeout(def(): self.parseCampaign(cb);, 1000)

        num_loaded = self.loadArchivedPages()
        result = window.Campaign.toJSON()
        result["R20Exporter_format"] = "1.0"
        result.campaign_title = self.title
        result.account_id = window.d20_account_id
        result.campaign_id = window.campaign_id
        self.campaign = result

        self.console.log("Waiting ", num_loaded * 5, " seconds for ", num_loaded, " archived pages to finish loading")
        self.console.setLabel1("Waiting for archived pages to finish loading (1/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(0, self.TOTAL_STEPS)
        if num_loaded > 0:
            i = -1
            updateProgress = def(): 
                nonlocal i
                i += 1
                self.console.setLabel2("Waiting... " + (num_loaded * 5 - i) + "s")
                self.console.setProgress2(i, num_loaded * 5)
                if i < num_loaded * 5:
                    setTimeout(updateProgress, 1000)
            updateProgress()

        setTimeout(def(): self._parseCampaignDelayed(result, cb);, num_loaded * 5000)
        return result

    def saveCampaign(self, filename=None):
        window.saveAs(toBlob(self.campaign), filename if filename else (self.title + ".json"))

    def exportCampaignJson(self, filename=None):
        self.parseCampaign(def(): self.saveCampaign(filename);)

    def exportCampaign(self):
        self.exportCampaignJson()

    def _imageToBlob(self, img, id, cb):
        c = document.createElement("canvas")
        ctx = c.getContext("2d")
        c.width = img.naturalWidth
        c.height = img.naturalHeight
        ctx.drawImage(img, 0, 0)
        c.toBlob(def(blob):
                     self.completedOperation(id)
                     cb(blob)
                 , "image/jpeg", 0.75)

    def downloadImageViaCanvas(self, url, cb, errorCB=None):
        id = self.newPendingOperation()
        img = new Image()
        img.onload = def(ev):
            self._imageToBlob(img, id, cb)
        img.onerror = def(error):
            self.completedOperation(id)
            if errorCB:
                errorCB()
        img.crossOrigin = ""
        img.src = url

    def downloadResource(self, url, cb, errorCB=None):
        id = self.newPendingOperation()
        
        window.fetch(url).then(def(response):
            if response.status == 200 or response.status == 0:
                return Promise.resolve(response.blob())
            else:
                return Promise.reject(new Error(response.statusText))
        ).then(def (blob):
            self.completedOperation(id)
            if cb:
                cb(blob)
        ).catch(def (error):
            self.completedOperation(id)
            if errorCB:
                errorCB()
        )

    # Most avatar/imgsrc URLs use the 'med' filename, even for the huge map files. We should download the appropriate sized
    # file depending on the image size we are looking for. We just download the highest resolution file that we can instead.
    def downloadR20Resource(self, folder, prefix, url, finallyCB, try_files=["original", "max", "med", "thumb"], use_canvas=False):
        filename = url.split("/")[-1].split(".")[0]
        # This is needed so we download the higher res file first.
        # Unfortunately, there are some CORS issues sometimes, so if higher res file fails, download the lower one.
        if try_files.length > 0:
            if filename in ["original", "max", "med", "thumb"]:
                new_url = url.replace("/" + filename + ".", "/" + try_files[0] + ".")
            else:
                new_url = url
                try_files = [""]

            successCB = self._makeAddBlobToZip(folder, prefix + ".png", finallyCB)
            errorCB = def():
                self.downloadR20Resource(folder, prefix, url, finallyCB, try_files[1:], use_canvas)    

            if use_canvas:
                self.downloadImageViaCanvas(new_url, successCB, errorCB)
            else:
                self.downloadResource(new_url, successCB, errorCB)
        else:
            if use_canvas:
                self.console.log("Couldn't download ", url, " with any alternative filename. Resource has become unavailable")
                finallyCB()
            else:
                self.downloadR20Resource(folder, prefix, url, finallyCB, use_canvas=True)

            

    def _makeNameUnique(self, names, orig_name):
        name = str(names.length).padStart(3, "0") + " - " + orig_name
        names.append(name)
        return name

    def _flattenJournalEntries(self, journal, _list=[]):
        for entry in journal:
            if jstype(entry) == "string":
                _list.append(entry)
            else:
                self._flattenJournalEntries(entry.i, _list)
        return _list

    def _makeAddBlobToZip(self, folder, filename, finallyCB):
        return def(blob):
            self._addFileToZip(folder, filename, blob)
            finallyCB()

    def _addCharacterToZip(self, folder, character, finallyCB):
        self._addFileToZip(folder, "character.json", toBlob(character))
        if (character.avatar? "") != "":
            self.downloadR20Resource(folder, "avatar", character.avatar, finallyCB)
        if character.defaulttoken?:
            if (character.defaulttoken.imgsrc? "") != "":
                self.downloadR20Resource(folder, "token", character.defaulttoken.imgsrc, finallyCB)
            if character.defaulttoken.sides?:
                for i, side in enumerate(character.defaulttoken.sides):
                    self.downloadR20Resource(folder, "side_" + i, side, finallyCB)
                
        if (character.bio? "") != "":
            self._addFileToZip(folder, "bio.html", new Blob([character.bio]))
        if (character.gmnotes? "") != "":
            self._addFileToZip(folder, "gmnotes.html", new Blob([character.gmnotes]))

    def _addHandoutToZip(self, folder, handout, finallyCB):
        self._addFileToZip(folder, "handout.json", toBlob(handout))
        if (handout.avatar? "") != "":
            self.downloadR20Resource(folder, "avatar", handout.avatar, finallyCB)
        if (handout.notes? "") != "":
            self._addFileToZip(folder, "notes.html", new Blob([handout.notes]))
        if (handout.gmnotes? "") != "":
            self._addFileToZip(folder, "gmnotes.html", new Blob([handout.gmnotes]))

    def _addJournalToZip(self, folder, journal, finallyCB):
        names = []
        for journal_entry in journal:
            if jstype(journal_entry) == "string":
                handout = self.findID(journal_entry, "handout")
                if handout is not None:
                    name = self._makeNameUnique(names, handout.name)
                    handout_dir = self._addZipFolder(folder, name)
                    self._addHandoutToZip(handout_dir, handout, finallyCB)
                else:
                    character = self.findID(journal_entry, "character")
                    if character is not None:
                        name = self._makeNameUnique(names, character.name)
                        char_dir = self._addZipFolder(folder, name)
                        self._addCharacterToZip(char_dir, character, finallyCB)
                    else:
                        self.console.log("Can't find handout with ID : ", journal_entry)
                        continue
            else:
                name = self._makeNameUnique(names, journal_entry.n)
                child_dir = self._addZipFolder(folder, name)
                self._addJournalToZip(child_dir, journal_entry.i, finallyCB)

    def _addPlaylistToZip(self, folder, playlist, finallyCB):
        names = []
        for audio in playlist:
            if jstype(audio) == "string":
                track = self.findID(audio, "track")
                if track is not None:
                    name = self._makeNameUnique(names, track.title)
                    if name[-4] != ".mp3":
                        name += ".mp3"
                    if track.source == "My Audio":
                        url = "https://app.roll20.net/audio_library/play/" + self.campaign.campaign_id  + "/" + track.track_id
                    elif track.source == "Tabletop Audio":
                        url = "https://s3.amazonaws.com/cdn.roll20.net/ttaudio/" + track.track_id.split("-")[0]
                    elif track.source == "Incompetech":
                        url =  "https://s3.amazonaws.com/cdn.roll20.net/incompetech/" + track.track_id.split("-")[0]
                    elif track.source == "Battlebards":
                        url = None
                        filename = track.track_id.split(".mp3-")[0] + ".mp3"
                        filename = encodeURIComponent(filename.replace(/%20%2D%20/g, " - "))
                        id = self.newPendingOperation()
                        _makePostCB = def(folder, name, finallyCB, id):
                            return def(url):
                                errorCB = def():
                                    self.console.log("Couldn't download Jukebox audio from url : ", url)
                                self.downloadResource(url, self._makeAddBlobToZip(folder, name, finallyCB), errorCB)
                                self.completedOperation(id)
                        _makePostErrorCB = def(track_id, finallyCB, id):
                            return def():
                                self.console.log("Couldn't download Jukebox audio from Battlebards : ", track_id)
                                self.completedOperation(id)
                                finallyCB()
                        
                        $.post("/editor/audiourl/bb", {"trackurl": filename}, _makePostCB(folder, name, finallyCB, id)) \
                            .fail(_makePostErrorCB(track.track_id, finallyCB, id))
                    else:
                        url = None
                        self.console.log("Can't download Audio track (", track.title , "). Unsupported source : ", track.source)
                    if url:
                        errorCB = def(url):
                            return def():
                                self.console.log("Couldn't download Jukebox audio from url : ", url)
                        self.downloadResource(url, self._makeAddBlobToZip(folder, name, finallyCB), errorCB(url))
                else:
                    self.console.log("Can't find Audio Track with ID : ", track)
                    continue
            else:
                name = self._makeNameUnique(names, audio.n)
                child_dir = self._addZipFolder(folder, name)
                self._addPlaylistToZip(child_dir, audio.i, finallyCB)

    def _addPageToZip(self, folder, page, finallyCB):
        self._addFileToZip(folder, "page.json", toBlob(page))
        if (page.thumbnail? "") != "":
            self.downloadR20Resource(folder, "thumbnail", page.thumbnail, finallyCB)
        if page.graphics.length > 0:
            graphics = self._addZipFolder(folder, "graphics")
            for graphic in page.graphics:
                self.downloadR20Resource(graphics, graphic.id, graphic.imgsrc, finallyCB)
                if graphic.sides?:
                    for i, side in enumerate(graphic.sides):
                        self.downloadR20Resource(graphics, graphic.id + "_side_" + i, side, finallyCB)
                

    def _saveCampaignZipCharacters(self, checkZipDone):
        self.console.log("Saving Characters")
        self.console.setLabel1("Saving Characters (4/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(3, self.TOTAL_STEPS)
        id = self.newPendingOperation()
        if self.campaign.characters.length > 0:
            characters = self._addZipFolder(self.zip, "characters")
            names = []
            for character in self.campaign.characters:
                name = self._makeNameUnique(names, character.name)
                char_dir = self._addZipFolder(characters, name)
                self._addCharacterToZip(char_dir, character, checkZipDone)

        self.savingStep = 1
        self.completedOperation(id)
        checkZipDone(True)

    def _saveCampaignZipJournal(self, checkZipDone):
        self.console.log("Saving Journal")
        self.console.setLabel1("Saving Journal handouts (5/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(4, self.TOTAL_STEPS)
        id = self.newPendingOperation()
        if self.campaign.journalfolder.length > 0:
            journal = self._addZipFolder(self.zip, "journal")
            self._addJournalToZip(journal, self.campaign.journalfolder, checkZipDone)
            all_ids = self._flattenJournalEntries(self.campaign.journalfolder)
            orphaned = []
            archived = []
            for handout in self.campaign.handouts:
                if handout.id not in all_ids:
                    orphaned.append(handout.id)
                elif handout.archived:
                    archived.append(handout.id)
            if archived.length > 0:
                folder = self._addZipFolder(journal, "Archived Handouts")
                self._addJournalToZip(folder, archived, checkZipDone)
            if orphaned.length > 0:
                folder = self._addZipFolder(journal, "Orphaned Handouts")
                self._addJournalToZip(folder, orphaned, checkZipDone)

        self.savingStep = 2
        self.completedOperation(id)
        checkZipDone(True)

    def _saveCampaignZipPage(self, checkZipDone):
        id = self.newPendingOperation()
        if self.savingPageIdx >= self.campaign.pages.length:
            self.savingStep = 4
            self.console.setPageLabel(None)
        else:
            page = self.campaign.pages[self.savingPageIdx]
            name = page.name if len(page.name) > 0  else "Untitled"
            self.console.setPageProgress(self.savingPageIdx, self.campaign.pages.length)
            self.savingPageIdx += 1
            self.console.setPageLabel(name + " (" + str(self.savingPageIdx) + "/" + str(self.campaign.pages.length) + ")")
            self.console.log("Saving Page : ", name, "(", self.savingPageIdx, "/", self.campaign.pages.length, ")")
            name = self._makeNameUnique(self.names, name)
            page_dir = self._addZipFolder(self.pages, name)
            self._addPageToZip(page_dir, page, checkZipDone)

        self.completedOperation(id)
        checkZipDone(True)

    def _saveCampaignZipPages(self, checkZipDone):
        self.console.log("Saving ", self.campaign.pages.length, " Pages")
        self.console.setLabel1("Saving Pages (6/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(5, self.TOTAL_STEPS)
        if self.campaign.pages.length > 0:
            self.pages = self._addZipFolder(self.zip, "pages")
            self.names = []
        self.savingStep = 3
        self.savingPageIdx = 0
        checkZipDone(True)

    def _saveCampaignZipJukebox(self, checkZipDone):
        self.console.log("Saving Jukebox audio")
        self.console.setLabel1("Saving Jukebox audio (7/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(6, self.TOTAL_STEPS)
        id = self.newPendingOperation()
        if self.campaign.jukeboxfolder.length > 0:
            jukebox = self._addZipFolder(self.zip, "jukebox")
            self._addPlaylistToZip(jukebox, self.campaign.jukeboxfolder, checkZipDone)
        self.savingStep = 5
        self.completedOperation(id)
        checkZipDone(True)


    def _saveCampaignZipDecks(self, checkZipDone):
        self.console.log("Saving Decks")
        self.console.setLabel1("Saving Decks (8/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(7, self.TOTAL_STEPS)
        id = self.newPendingOperation()
        if self.campaign.decks.length > 0:
            decks = self._addZipFolder(self.zip, "decks")
            names = []
            for deck in self.campaign.decks:
                name = self._makeNameUnique(names, deck.name)
                deck_dir = self._addZipFolder(decks, name)
                if deck.avatar?:
                    self.downloadR20Resource(deck_dir, "avatar", deck.avatar, checkZipDone)
                card_names = []
                for card in deck.cards:
                    card_name = self._makeNameUnique(card_names, card.name? "")
                    if card.avatar?:
                        self.downloadR20Resource(deck_dir, card_name, card.avatar, checkZipDone)
        self.savingStep = 6
        self.completedOperation(id)
        checkZipDone(True)

    def _saveCampaignZipTables(self, checkZipDone):
        self.console.log("Saving Rollable Tables")
        self.console.setLabel1("Saving Rollable Tables (9/" + self.TOTAL_STEPS + ")")
        self.console.setProgress1(8, self.TOTAL_STEPS)
        id = self.newPendingOperation()
        if self.campaign.tables.length > 0:
            tables = self._addZipFolder(self.zip, "tables")
            names = []
            for table in self.campaign.tables:
                name = self._makeNameUnique(names, table.name)
                table_dir = self._addZipFolder(tables, name)
                item_names = []
                for item in table.items:
                    if item.avatar? and item.avatar != "":
                        item_name = self._makeNameUnique(item_names, item.name ? "")
                        self.downloadR20Resource(table_dir, item_name, item.avatar, checkZipDone)
        self.savingStep = 7
        self.completedOperation(id)
        checkZipDone(True)

    def saveCampaignZip(self, filename=None):
        if self.zip is not None:
            self.console.error("Saving already in progress. Can't be cancelled.")
            return
        filename = filename if filename else (self.title + ".zip")
        self.zip = self._createZipFile()
        self._total_size = 0
        self.savingStep = 0
        self._addFileToZip(self.zip, 'campaign.json', toBlob(self.campaign))
        if self.campaign.chat_archive?:
            self._addFileToZip(self.zip, 'chat_archive.json', toBlob(self.campaign.chat_archive))
        checkZipDone = def(show_pending=False):
            if not self.hasPendingOperation():
                #self.console.log("No more pending operations. Current step is ", self.savingStep)
                if self.savingStep == 0:
                    setTimeout(def(): self._saveCampaignZipCharacters(checkZipDone);, 0)
                elif self.savingStep == 1:
                    setTimeout(def(): self._saveCampaignZipJournal(checkZipDone);, 0)
                elif self.savingStep == 2:
                    setTimeout(def(): self._saveCampaignZipPages(checkZipDone);, 0)
                elif self.savingStep == 3:
                    setTimeout(def(): self._saveCampaignZipPage(checkZipDone);, 0)
                elif self.savingStep == 4:
                    setTimeout(def(): self._saveCampaignZipJukebox(checkZipDone);, 0)
                elif self.savingStep == 5:
                    setTimeout(def(): self._saveCampaignZipDecks(checkZipDone);, 0)
                elif self.savingStep == 6:
                    setTimeout(def(): self._saveCampaignZipTables(checkZipDone);, 0)
                else:
                    setTimeout(def():
                                   self._saveZipToFile(self.zip, filename)
                                   self.zip = None
                               , 0)
                if show_pending:
                    self.console.log("Download operations in progress : ", self._pending_operations.length)
                    self.console.setProgress2(0, self._pending_operations.length)

        checkZipDone()

    def exportCampaignZip(self, filename=None):
        self.console.show()
        self.parseCampaign(def(campaign):self.saveCampaignZip(filename);)

class ModalWindow:
    def __init__(self, title="", modalClass="modal"):
        self.title = title
        modal_div = $("body ." + modalClass)
        if modal_div.length > 0:
            modal_div.remove()
        self.modal_div = $('<div class="' + modalClass + '"><div class="' + modalClass + '-content"></div></div>')
        css = """
            /* The Modal (background) */
            .modal {
                display: none; /* Hidden by default */
                position: fixed; /* Stay in place */
                z-index: 100000; /* Sit on top */
                padding-top: 50px; /* Location of the box */
                left: 0;
                top: 0;
                width: 100%; /* Full width */
                height: 100%; /* Full height */
                overflow: auto; /* Enable scroll if needed */
                background-color: rgb(0,0,0); /* Fallback color */
                background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            }
            
            /* Modal Content */
            .modal-content {
                background-color: #fefefe;
                margin: auto;
                padding: 20px;
                border: 3px solid #333;
                border-radius: 25px;
                width: 80%;
                height: 80%;
                overflow: auto; /* Enable scroll if needed */
                overflow-x: hidden; /* Disable horizontal scroll */
            }
            .modal-content .title {
                position: relative;
                top: -20px;
                left: -20px;
                width: calc(100% + 40px);
                text-align: center;
                color: white;
                background-color: black;
                font-size: 1.25em;
                font-weight: bold;
            }
            .modal-content .log {
                background-color: #ddd;
            }
            .modal-content .warn {
                background-color: gold;
                font-style: italic;
            }
        """.replace(/modal/g, modalClass)
        $("body").append($("<style>" + css + "</style>"))
        $("body").append(self.modal_div)
        self.content = self.modal_div.find("." + modalClass + "-content")
        self.main_progress = new ProgressBar()
        self.mp_current = self.mp_total = 1
        self.second_progress = new ProgressBar()
        self.sp_current = self.sp_total = 1
        self.page_progress = new ProgressBar()
        self.pp_current = self.pp_total = 1
        self.setPageLabel(None)
        self.clear()
        self.hide()

    def clear(self):
        self.content.html("")
        self.content.append($('<div class="title">' + self.title + '</div>'))
        self.content.append(self.main_progress.getElement())
        self.content.append(self.page_progress.getElement())
        self.content.append(self.second_progress.getElement())
        self.content.append($('<div class="warn"></div>'))
        self.content.append($('<details class="log"><summary>Log</summary></details>'))

    def hide(self):
        self.modal_div.css("display", "none")

    def show(self):
        self.modal_div.css("display", "block")

    def append(self, content):
        self.content.append($(content))

    def log(self, *args):
        console.log(*args)
        line = ""
        for a in args:
            line += str(a) + " "
        self.content.find(".log").append("<p>" + line.replace(/\n/g, "<br/>") + "</p>")

    def warn(self, *args):
        console.warn(*args)
        line = ""
        for a in args:
            line += str(a) + " "
        self.content.find(".warn").append($("<p>" + line.replace(/\n/g, "<br/>") + "</p"))

    def setLabel1(self, label):
        self.main_progress.setLabel(label)
    def setLabel2(self, label):
        self.second_progress.setLabel(label)
    def setPageLabel(self, label):
        if label:
            self.page_progress.getElement().css("display", "block")
            self.page_progress.setLabel(label)
        else:
            self.page_progress.getElement().css("display", "none")
            self.setPageProgress(0, 1)
    def setProgress1(self, current, total=None):
        self.main_progress.setProgress(current, total)
        self.mp_current = current
        self.mp_total = total if total else self.main_progress.total
    def setProgress2(self, current, total=None):
        self.second_progress.setProgress(current, total)
        self.sp_current = current
        self.sp_total = self.second_progress.total
        percent = self.sp_current / self.sp_total
        if self.pp_total > 1:
            self.page_progress.setProgress(self.pp_current + percent)
            percent = self.pp_current / self.pp_total
        self.main_progress.setProgress(self.mp_current + percent)
    def setPageProgress(self, current, total=None):
        self.page_progress.setProgress(current, total)
        self.pp_current = current
        self.pp_total = self.page_progress.total
        percent = self.pp_current / self.pp_total
        self.main_progress.setProgress(self.mp_current + percent)


class ProgressBar:
    def __init__(self, label="", current=0, total=100):
        self.progress = $("""<div style="width: 100%; background-color: grey; margin: 5px">
                               <span style="float: left; position: relative; left: 50%; line-height: 20px">
                                  <strong style="float: left; position: relative; left: -50%"></strong>
                               </span>
                               <div style="background-color: dodgerblue; height: 20px;"></div>
                             </div>""")
        self.setLabel(label)
        self.setProgress(current, total)

    def setLabel(self, label):
        self.progress.find("strong").html(label)

    def setProgress(self, current, total=None):
        if total:
            self.total = total
        self.current = current
        percent = self.getPercent()
        self.progress.find("div").css("width", str(percent.toFixed(2)) + "%")

    def getPercent(self):
        if self.total == 0:
            percent = 100
        else:
            percent = self.current * 100 / self.total
        return percent

    def getElement(self):
        return self.progress
        
def R20Exporter_init():
    console.log("Roll20 Campaign exporter loaded.")
    console.log("To export your Roll20 campaign, enter R20Exporter.exportCampaignZip() or click on the button in the Settings sidebar.")
    window.R20Exporter = new Campaign($("head title").text().trim().replace(" | Roll20", ""))
    window.ProgressBar = ProgressBar

# We need to create the campaign only after the DOM is loaded, otherwise when R20ES is installed, we get an error
# unable to find '$' because r20es slows down the download of the jquery external script it seems.
# We also need to be able to run it as standalone.
if $?:
    R20Exporter_init()
else:
    window.addEventListener ("DOMContentLoaded", R20Exporter_init)
